　　ARTS，即：每周完成一个ARTS：每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章，至少坚持一年。（也就是 Algorithm、Review、Tip、Share 简称ARTS）。

# LeetCode
本周算法题：[1.两数字之和](https://leetcode-cn.com/problems/two-sum/solution/)

问题描述：
```
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```
分析：
```
方法一：暴力遍历
遍历每个元素x，查找是否存在一个与target-x相等的目标元素。
时间复杂度：O(n^2)
空间复杂度：O(1)

方法二：两遍哈希表
使用哈希表，保持数组中每个元素与其对索引相对应。
先遍历一遍数组初始化哈希表。
再遍历一次数组判断哈希表中是否存在target-nums[i],注意该目标不能是nums[i]本身。

用空间换取时间。
时间复杂度：O(n)
空间复杂度：O(n)

方法三：一遍哈希表
事实上，我们可以一遍完成。在迭代并将元素插入表中的同时，检查当前表中元素是否已经存在存在当前元素所对应的元素。如果存在，则找到对应解。

时间复杂度：O(n)
空间复杂度：O(n)
```
代码:
```
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    let map = new Map();
    for(let i = 0; i < nums.length; i++){
        let complement = target - nums[i];     
        if(map.has(complement)){
            return [map.get(complement),i];
        }
        map.set(nums[i],i);
    }
    return [];
};

// 测试用例
输入 
[2,7,11,15]
9
输出 
[0,1]
预期
[0,1]

```
